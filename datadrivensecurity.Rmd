---
title: "Impacto de las vulnerabilidades en c√°maras IP"
author: "Isabel Garcia Padilla, Javier Taberner Nicolas, Roxana Madalina Gogonea"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(cache = TRUE)
```

```{r installPackages, include=FALSE}
packages <- c("devtools", "tidyr", "dplyr", "stringr", "foreach", "gsubfn", "ggplot2")

cran.repos <- "http://cran.us.r-project.org"

lapply(packages, function(x) {
  if (!require(x))
    install.packages(x, repos = cran.repos)
  library(x, character.only = TRUE)
})
devtools::install_github("hrbrmstr/shodan")
library(shodan)
```

```{r, loadCVEFile, include=FALSE}
## Download sysdata file that contains CVEs and CPEs information
download.file(url = "https://github.com/r-net-tools/security.datasets/raw/master/net.security/sysdata.rda", 
              destfile = "sysdata.rda")

## Load sysdata file
load("sysdata.rda")

## Create new lists with CVEs information

cves <- netsec.data$datasets$cves
## Create a searching list that will be used to retrieve the CVEs related to cameras vulnerabilities
cve_search_list <- c("axis.*?camera", "d-link.*?camera", "tp-link.*?sc", "canon.
                     *?camera", "vivotek.*?camera", "sony.*?camera")

## Create a list with the fields that will be extracted from the cves data frame
cve_selected_fields <- c("cve", "cvss", "description", "cpe.software")

## Create a list with the fields in which the cpe information will be divided 
cpe_fields <- c("cpe", "type", "vendor", "model", "version")

## List with special characters that need to be removed while cleaning the data
special_chars_to_remove <- c("_", "%")

## Get list of CVEs related to camera vulnerabilities
cameras <- data.frame(cves %>% filter(str_detect(cpe.software, paste(cve_search_list, collapse = "|"))) %>% select(cve_selected_fields))

## Define a new empty data frame in which the parsed data will be stored
cve_cameras_data <- data.frame(cve = character(), 
                               cvss = double(), 
                               description = character(), 
                               type = character(), 
                               vendor = character(), 
                               model = character(), 
                               version = double())

##Get the CPE software information and create a new dataframe with the information that is related to cameras
for (row in 1:nrow(cameras)) {
  camera <- cameras[row,]
  
  ##Parse cpe.software to JSON and filter its information in order to extract only camera related information
  ##Once filtered, separate fields in cpe fields: cpe, type, vendor, model and version
  software_list <- data.frame(software = jsonlite::fromJSON(camera$cpe.software), stringsAsFactors = FALSE) %>% filter(str_detect(software, paste(cve_search_list, collapse = "|"))) %>% separate(software, cpe_fields, sep = ":") %>% drop_na() %>% filter(type == "/h")
  
  if (nrow(software_list)[1] > 0) {
    ##Remove special chars
    software_list$model <- gsub(paste(special_chars_to_remove, collapse = "|"), ' ', software_list$model)
    
    cve_cameras_data = rbind(cve_cameras_data, data.frame(camera[1:3], software_list[2:5])) 
  }
}
```

```{r, getShodanInformation, include=FALSE}
## Setup a list with searching values
shodan_search_list <- c("axis camera", "d-link dcs", "tp-link ip-camera", 
                        "canon network camera", "vivotek camera", "sony camera")

## List with regex expressions needed to get the cameras information from Shodan results
regex_camera_search <- list(axis = "((AXIS|Axis).*Camera.(\\w)+(.(\\d)+)+)", 
                            dlink = "(DCS-(\\d)+\\w)", tplink = "TP-Link IP-Camera", 
                            canon = "Canon Network Camera", vivotek = "Vivotek Network Camera", 
                            sony = "((SONY|Sony).Network Camera.(\\w)+-(\\w)+)")

## Function that parses AXIS cameras informtion
## It returns the input dataset with vendor, model and version values                          
parse_axis_camera <- function(software_info){
  for (i in 1:nrow(software_info)) {
    ## Apply regex
    rgx <- strapply(software_info[i,]$data, regex_camera_search["axis"])
    if (length(rgx) > 0 && !is.null(rgx[[1]])) {
      info <- strsplit(unlist(rgx), " ")
      if (length(info) > 0) {
        ## Set vendor, model and version information
        info <- info[[1]]
        software_info[i,]$vendor <- "axis"
        software_info[i,]$model <- tolower(paste(info[2:(length(info)-1)], collapse = " "))
        software_info[i,]$version <- info[length(info)]
      }
    }
  }
  software_info
}

## Function that parses Sony cameras informtion
## It returns the input dataset with vendor, model and version values
parse_sony_camera <- function(software_info){
  for (i in 1:nrow(software_info)) {
    ## Apply regex
    rgx <- strapply(software_info[i,]$data, regex_camera_search["sony"])
    if (length(rgx) > 0 && !is.null(rgx[[1]])) {
      info <- strsplit(unlist(rgx), " ")
      if (length(info) > 0) {
        ## Set vendor, model and version information
        info <- info[[1]]
        software_info[i,]$vendor <- "sony"
        software_info[i,]$model <- tolower(paste(info[2:(length(info)-1)], collapse = " "))
        software_info[i,]$version <- tolower(info[length(info)])
      }
    }
  }
  software_info
}

## Function that parses D-Link cameras informtion
## It returns the input dataset with vendor, model and version values
parse_dlink_camera <- function(software_info){
  for (i in 1:nrow(software_info)) {
    rgx <- strapply(software_info[i,]$data, regex_camera_search["dlink"])
    if (length(rgx) > 0 && !is.null(rgx[[1]])) {
        ## Set vendor and model information
        info <- rgx[[1]]
        software_info[i,]$vendor <- "d-link"
        software_info[i,]$model <- tolower(info[1])
    }
  }
  software_info
}

## Get software information depending on the camera vendor
get_camera_software <- function(software_info, shodan_query){
  if (shodan_query == shodan_search_list[1]) {
    software_info <- parse_axis_camera(software_info)
  } else if (shodan_query == shodan_search_list[2]) {
    software_info <- parse_dlink_camera(software_info)
  } else if (shodan_query == shodan_search_list[3]) {
    software_info$vendor <- "tp-link"
    software_info$model <- "ip-camera"
  } else if (shodan_query == shodan_search_list[4]) {
    software_info$vendor <- "canon"
    software_info$model <- "network camera"
  } else if (shodan_query == shodan_search_list[5]) {
    software_info$vendor <- "vivotek"
    software_info$model <- "network camera"
  } else if (shodan_query == shodan_search_list[6]) {
    software_info <- parse_sony_camera(software_info)
  }
  
  software_info
}

## Shodan search function
shodan_search_function <- function(shodan_query) {
  result_to_return <- NULL
  
  ## Perform first search, by defult it returns the first 100 results
  result <- shodan_search(query = shodan_query)
  
  ## If the result has more than 100 elements, do as many search as needed
  if (result$total > 100) {
    result_to_return = rbind(result_to_return, data.frame(country_code = result$matches$location$country_code, 
                                                          country_name = result$matches$location$country_name, 
                                                          latitude = result$matches$location$latitude, 
                                                          longitude = result$matches$location$longitude, 
                                                          ip_str = result$matches$ip_str, 
                                                          data = result$matches$data, 
                                                          vendor = NA, 
                                                          model = NA, 
                                                          version = 0, 
                                                          stringsAsFactors = FALSE))

    for (i in 2:round(result$total/100)) {
      result <- shodan_search(query = shodan_query, page = i)
      
      result_to_return = rbind(result_to_return, data.frame(country_code = result$matches$location$country_code, 
                                                            country_name = result$matches$location$country_name, 
                                                            latitude = result$matches$location$latitude, 
                                                            longitude = result$matches$location$longitude, 
                                                            ip_str = result$matches$ip_str, 
                                                            data = result$matches$data, 
                                                            vendor = NA, 
                                                            model = NA, 
                                                            version = 0, 
                                                            stringsAsFactors = FALSE))
    }
  } else {
    result_to_return <- data.frame(country_code = result$matches$location$country_code, 
                                   country_name = result$matches$location$country_name, 
                                   latitude = result$matches$location$latitude, 
                                   longitude = result$matches$location$longitude, 
                                   ip_str = result$matches$ip_str, 
                                   data = result$matches$data, 
                                   vendor = NA, 
                                   model = NA, 
                                   version = 0, 
                                   stringsAsFactors = FALSE)
  }
  
  ## Once we got the entire list of results, extract the vendor, model and verion values
  get_camera_software(result_to_return, shodan_query)
}

## Create a new object in which the shodan results will be saved
shodan_cameras_data <- NULL

## Perdorm shodan searches 
for (i in 1:length(shodan_search_list)) {
  shodan_cameras_data = rbind(shodan_cameras_data, shodan_search_function(shodan_search_list[i]))
}

## Drop rows with NA values
shodan_cameras_data <- shodan_cameras_data %>% drop_na()
```

```{r, mergeShodanAndCVEInfo, include=FALSE}
## Join shodan search result with cameras CVEs information
shodan_cves_join <- left_join(shodan_cameras_data, cve_cameras_data)

## Drop rows with NA values 
shodan_cves_join.no_na <- shodan_cves_join %>% drop_na()
```

```{r, transformValuesInFactors, include=FALSE}
## Transform needed fields into factors
shodan_cves_join.no_na <- transform(shodan_cves_join.no_na, model = factor(model))
shodan_cves_join.no_na <- transform(shodan_cves_join.no_na, vendor = factor(vendor))
shodan_cves_join.no_na <- transform(shodan_cves_join.no_na, country_name = factor(country_name))

shodan_cameras_data <- transform(shodan_cameras_data, model = factor(model))
shodan_cameras_data <- transform(shodan_cameras_data, vendor = factor(vendor))
shodan_cameras_data <- transform(shodan_cameras_data, country_name = factor(country_name))
shodan_cameras_data <- transform(shodan_cameras_data, country_code = factor(country_code))

cve_cameras_data <- transform(cve_cameras_data, vendor = factor(vendor))
cve_cameras_data <- transform(cve_cameras_data, model = factor(model))
```

```{r, echo=FALSE, results='hide'}
cve.cameras.count <- nrow(cve_cameras_data)
```
### Introducci√≥n
La pregunta que ha dado origen a este estudio es saber cu√°ntas c√°maras IP (como categor√≠a de c√°mara digital) est√°n abiertas y pueden ser hackeadas, es decir vulnerables, en todo el mundo. En un principio la idea original era averiguar el n√∫mero de c√°maras que podr√≠an ser objeto de vulnerabilidades, pero restringi√©ndonos a Espa√±a. La b√∫squeda no fue muy productiva ya que no encontramos la cantidad suficiente para que el estudio fuera representativo.  

#### ¬øPor qu√© c√°maras IP? 
Una c√°mara IP es una c√°mara que emite las im√°genes directamente a internet sin necesidad de un ordenador.  
Una c√°mara de red incorpora su propio miniordenador, lo que le permite emitir v√≠deo por s√≠ misma. Adem√°s de comprimir el v√≠deo y enviarlo, puede tener una gran variedad de funciones:  

   - Env√≠o de correos electr√≥nicos con im√°genes.  
   - Activaci√≥n mediante movimiento de la imagen.  
   - Activaci√≥n mediante movimiento de s√≥lo una parte de la imagen.  
   - Activaci√≥n a trav√©s de otros sensores.  
   - Control remoto para mover la c√°mara y apuntar a una zona.  
   - Programaci√≥n de una secuencia de movimientos en la propia c√°mara.  
   - Posibilidad de guardar y emitir los momentos anteriores a un evento.  
 
Las c√°maras IP permiten ver en tiempo real qu√© est√° pasando en un lugar, aunque est√© a miles de kil√≥metros de distancia. Son c√°maras de v√≠deo de gran calidad que tienen incluido un ordenador a trav√©s del que se conectan directamente a Internet.  
  
  
**Caracter√≠sticas de un c√°mara IP**

1. Grabador de datos  
   Hoy en d√≠a muchos de los sistemas de videovigilancia o c√°maras de seguridad tambi√©n llevan sistemas de grabaci√≥n de im√°genes autom√°ticos. Se puede acceder desde cualquier dispositivo conectado a Internet.  
   
2. Visi√≥n en vivo  
   Con las c√°maras IP se puede ver qu√© est√° pasando en este preciso momento. El usuario se conecta a trav√©s de Internet a una direcci√≥n IP que tienen sus c√°maras, algunos modelos permiten interacci√≥n con la ayuda de audio incorporado y las funciones de tomar fotograf√≠as y grabar en video lo que est√° pasando.  
   
3. Microordenador
   Una c√°mara IP tiene incorporado un ordenador, peque√±o y especializado en ejecutar aplicaciones de red.  
  
**Problemas c√°maras IP vulnerables**  

Adem√°s de problemas relacionados con la [privacidad de los ususarios], las vulnerabilidades en c√°maras IP tambi√©n pueden ser utilizadas para llevar a cabo [otro tipo de ataques] a partir de botnets creadas con estos dispositivos.

[privacidad de los ususarios]:https://www.av-test.org/es/noticias/news-single-view/seguridad-de-camaras-ip-ver-y-ser-visto/
[otro tipo de ataques]:http://www.elperiodico.com/es/sociedad/20161021/ataque-informatico-deja-sin-servicio-dos-horas-twtter-spotify-5579786  

Las c√°maras IP son altamente vulnerables ya que gran parte de sus usuarios no dan la importancia que deber√≠an a las configuraciones de seguridad, dejando en muchas ocasiones contrase√±as por defecto o directamente sin ning√∫n tipo de protecci√≥n.  

Internet nos ofrece varias maneras de buscar las c√°maras que se encuentran accesibles desde cualquier parte del mundo, siendo la m√°s conocida y utilizada [Shodan]. Este buscador nos permite buscar todo tipo de dispositivos conectado a Internet. Para ofrecer este servicio, Shodan recorre toda la red mandando peticiones a puertos y esperando su respuesta, toda esta informaci√≥n la va almacenando en una base de datos que cualquier usuario puede consultar.  

[Shodan]:https://www.shodan.io/

Pero tambi√©n hay p√°ginas como [Insecam] que se encargan de hacer las b√∫squedas por nosotros y nos ofrecen un listado con todas las c√°maras accesibles. Visitado esta web, se puede ver que estas c√°maras graban todo tipo de lugares: negocios, garajes, carreteras, hoteles e incluso hogares.

[Insecam]:http://www.insecam.org/

Lo m√°s grave de estas webs es que no s√≥lo nos proporcionan la imagen que emiten las c√°maras, sino tambi√©n su ubicaci√≥n y aqu√≠ es donde nuestra seguridad f√≠sica y no solo intromisi√≥n privada que unas im√°genes que se emiten al mundo, ya que dicta f√≠sicamente donde nos situamos. Este hecho ha generado nuevos problemas, uno de ello siendo el aumento en [robos en hogares].  

[robos en hogares]:https://www.av-test.org/es/noticias/news-single-view/seguridad-de-camaras-ip-ver-y-ser-visto/
   
Por otro lado, hay que destacar que a√±o tras a√±o el n√∫mero de c√°maras de videovigilancia se ha visto aumentado no s√≥lo a nivel mundial sino tambi√©n a [nivel estatal]. Este hecho multiplica los problemas de privacidad con los que tienen que lidiar instituciones como la [AEPD].

[nivel estatal]:https://www.elconfidencial.com/espana/2015-07-20/gran-hermano-videovigilancia-privacidad-proteccion-datos_932611/
[AEPD]:http://www.agpd.es/portalwebAGPD/index-ides-idphp.php

### Idea inicial  

La pregunta inicial constaba en determinar qu√© c√°maras de las que hay abiertas p√∫blicamente, no cumpl√≠an con la ley de protecci√≥n de datos. Para ello, la idea era utilizar la informaci√≥n devuelta por la API de Shodan. Esta devuelve un listado en formato JSON de la informaci√≥n que recoge de cada c√°mara encontrada. De esta manera, la idea consist√≠a en intentar determinar en cada una de los objetos devueltos, ciertas palabras clave que nos permitiesen determinar si se trataba de una c√°mara que pudiera mostrar contenido que infringiese la ley de protecci√≥n de datos.  

A lo largo de esta fase se encontraron varios problemas que supusieron un cambio en la pregunta inicial. En primer lugar, al disponer de una cuenta gratuita de Shodan, la utilizaci√≥n de su API para este tipo de usuarios es limitada, permitiendo s√≥lo obtener las 100 primeras b√∫squedas y no dejando utilizar filtros que permiten afinar m√°s las b√∫squedas. Por otro lado, en los resultados de las b√∫squedas, no se nos devolv√≠a informaci√≥n sobre qu√© podr√≠an estar enfocando las c√°maras por lo tanto, la idea inicial de utilizar palabras clave para poder clasificarlas no se podr√≠a aplicar. Por otro lado, en un primer instante se pens√≥ acotar el estudio a Espa√±a pero dado que la informaci√≥n encontrada no representaba un gran volumen de datos, se decidi√≥ hacer un estudio a nivel mundial.  

Llegados a este punto, decidimos cambiar la pregunta y determinar **qu√© fabricantes de c√°maras son m√°s vulnerables**. Para ello se han tenido que utilizar dos fuentes de datos diferentes:  

1. En primer lugar un [dataset con la informaci√≥n de los CVEs]. Este fichero ya viene preparado para su utilizaci√≥n en R por lo tanto s√≥lo se ha necesitado parsear los datos para que estuviesen en el formato necesario para el estudio.  
2. Como en los casos anteriores, la API de Shodan para recoger la informaci√≥n sobre las c√°maras IP. Para facilitar su uso, se ha utilizado una [librer√≠a para R] que nos ha permitido obtener directamente un dataset con los resultados de las b√∫squedas.  

[dataset con la informaci√≥n de los CVEs]:https://github.com/r-net-tools/security.datasets/tree/master/net.security  
[librer√≠a para R]: https://github.com/hrbrmstr/shodan  

C√≥mo se ver√° a continuaci√≥n, a pesar de la gran variedad de fabricantes de c√°maras IP, la informaci√≥n obtenida no ha sido la esperada inicialmente.  

El primer problema con el que nos encontramos a la hora de recoger los datos necesarios, fue determinar la lista de c√°maras de las que har√≠amos el estudio.  

En un primer instante se pens√≥ en extraer toda la informaci√≥n relacionada con c√°maras de los CPEs, posteriormente filtrar los CVEs que estuviesen relacionados con vulnerabilidades de c√°maras encontradas en los CPEs y por √∫ltimo, con la ayuda de Shodan hacer las b√∫squedas que nos permitiesen determinar cu√°ntas c√°maras se ve√≠an afectadas por estos fallos de seguridad. Pero el problema que tuvimos es que, buscando vulnerabilidades, observamos que hab√≠a informaci√≥n sobre c√°maras que no estaban presentes en el fichero de los CPEs, por lo tanto descartamos hacer la b√∫squeda a partir de los CPEs.  

En la siguiente prueba, nos centramos en extraer los CVEs que definiesen una vulnerabilidad relacionada con c√°maras IP y una vez obtenida dicha informaci√≥n, buscar cu√°ntas c√°maras, junto a sus modelos y versiones, se ve√≠an afectadas a nivel mundial por estas vulnerabilidades. Pero a causa de hacer b√∫squedas muy acotadas, los resultados obtenidos no fueron suficientes para poder sacar ning√∫n tipo de conclusiones. Adem√°s al buscar s√≥lo modelos vulnerables, no pod√≠amos determinar que c√°maras no eran vulnerables.     

En la tercera y √∫ltima prueba, intentamos hacer b√∫squedas m√°s gen√©ricas, por fabricantes de c√°maras IP y posteriormente extraer informaci√≥n extra de modelos y versiones, a partir de los resultados devueltos por Shodan. De esta manera, analizando los resultados que Shodan devuelve al hacer b√∫squedas por diferentes modelos de c√°maras, se escogieron los siguientes fabricantes: **AXIS, D-Link, TP-Link, Canon, Vivotek y Sony**. El criterio de selecci√≥n de c√°maras se bas√≥ en analizar qu√© resultados de Shodan nos devolv√≠an informaci√≥n extra sobre modelo y versi√≥n de c√°maras. Esto √∫ltimo fue un problema ya que cada fabricante muestra los datos de sus c√°maras de una manera distinta y no todos hacen p√∫blica esta informaci√≥n por lo tanto Shodan no la puede indexar.  

Esta √∫ltima prueba se realiz√≥ con la idea de poder obtener otras posibles c√°maras vulnerables que no se hab√≠an encontrado con la prueba anterior, adem√°s de incluir modelos que no son vulberables. Para poder obtener dicha informaci√≥n, se tuvieron que seguir los siguientes pasos:  

1. Hacer las b√∫squedas de cada uno de los fabricantes escogidos.  
2. Extraer informaci√≥n relevante a partir de los resultados obtenidos, en concreto nos centramos en obtener el modelo y la versi√≥n de cada c√°mara. Como ya se ha mencionado, cada fabricante muestra lo datos de sus c√°maras de una manera distinta, por lo tanto este paso result√≥ m√°s complejo ya que se tuvo que implementar una funci√≥n de extracci√≥n de informaci√≥n diferente para cada fabricante. Por otro lado, tres de los fabricantes buscados no incluyen informaci√≥n del modelo ni versi√≥n, acotando a√∫n m√°s el estudio.  

Una vez obtenida la lista de c√°maras junto a su informaci√≥n t√©cnica, se cruz√≥ con los datos obtenidos de los CVEs. De esta manera se encontraron un total de `r cve.cameras.count ` c√°maras vulnerables que como en los casos anteriores, no son suficientes para poder hacer un estudio real de la situaci√≥n mundial de vulnerabilidades en este tipo de dispositivos. Adem√°s como en los casos anteriores, el √∫nico fabricante del que se han podido encontrar c√°maras vulnerables es AXIS. Esto no quiere decir que los dem√°s fabricantes no lo sean sino que a causa de no disponer de suficientes datos, no se han podido encontrar vulnerabilidades.  
  
  
###An√°lisis de resultados  

Como se ha adelantado, la informaci√≥n obtenida no es suficiente como para poder realizar un estudio concluyente del estado de las vulnerabilidades presentes en las c√°maras IP encontradas a nivel mundial.  

Como podemos observar en la siguiente gr√°fica, el mayor productor, vendedor de c√°maras IP, seg√∫n la informaci√≥n que hemos podido obtener es AXIS (fabricante sueco de c√°maras de red para las industrias de seguridad f√≠sica y videovigilancia). Su gran expansi√≥n se debe ya sea a su precio o a su expansi√≥n al mercado del mundo de las c√°maras IP de videovigilancia. Esta marca es seguida por D-Link y TP-Link, proveedores no s√≥lo de c√°maras IP si no tambi√©n de otros tipos de equipos de red.

```{r, foundCamsByVendor, fig.align='center'}
g <- ggplot(shodan_cameras_data, aes(vendor, fill = vendor))
g + geom_bar() + labs(title = "Recuento de c√°maras IP a nivel mundial", y = "Recuento de c√°maras", x = "Fabricante", fill = "Fabricante")
```

```{r, axisVulnsCount, fig.align='center'}
axis.vulns.count <- nrow(cve_cameras_data[cve_cameras_data$vendor == "axis",])
```

Por otro lado, AXIS, como fabricante m√°s utilizado por los usuarios y siempre con los datos que disponemos, es casualmente la marca con la que m√°s vulnerabilidades presentan sus productos, concretamente `r axis.vulns.count `. 

```{r, vulnsByVendor, fig.align='center'}
g <- ggplot(cve_cameras_data, aes(vendor, fill = model))
g + geom_bar() + labs(title = "Recuento de vulnerabilidades por fabricante", y = "Recuento de vulnerabilidades", x = "Fabricante", fill = "Modelo")
```

A partir de los datos encontrados, se puede observar que es especialmente vulnerable el modelo [AXIS 2100 Network Camera].  

[AXIS 2100 Network Camera]:https://www.axis.com/files/datasheet/2100/2100_es_ds.pdf

```{r, axisVulns, fig.align='center'}
g <- ggplot(cve_cameras_data[cve_cameras_data$vendor == "axis",], aes(model, fill = version))
g + geom_bar() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = "Recuento de vulnerabilidades c√°maras AXIS", y = "Recuento de vulnerabilidades", x = "Modelo", fill = "Versi√≥n")
```  

Por otro lado, analizando sus versiones, no se puede determinar ning√∫n patr√≥n relacionado con este dato ya que como se puede observar en la gr√°fica anterior, las vulnerabilidades est√°n repartidas entre todas las versiones, por lo tanto no se podr√≠a decir que una modelo en concreto es m√°s seguro que otro.  

```{r, axisVulnsModelCount, include=FALSE}
vulnerable.cams.count <- nrow(shodan_cves_join.no_na)
vulnerable.models.count <- length(table(shodan_cves_join.no_na$model))
```

Cruzando la informaci√≥n obtenida de los CVEs y con Shodan, tenemos como resultado las vulnerabilidades presentes entre las c√°maras encontradas a nivel mundial. A pesar de lo esperado inicialmente y como ya se ha adelantado en el apartado anterior, s√≥lo se han conseguido encontrar c√°maras vulnerables AXIS. Esto se debe principalmente a que la informaci√≥n encontrada con Shodan no ha sido lo suficientemente detallada como para poder extraer todos los datos necesarios para realizar el estudio.  

De esta manera, a nivel mundial, se han encontrado un total de `r vulnerable.cams.count ` c√°maras vulnerables, repartidas de la siguiente manera:

```{r, vulnsByCountry, fig.align='center'}
g <- ggplot(shodan_cves_join.no_na, aes(country_code, fill = vendor))
g + geom_bar() + labs(title = "Recuento de vulnerabilidades por pa√≠s", y = "Recuento de vulnerabilidades", x = "Pa√≠s", fill = "Fabricante")
```

Hay que destacar que, a nivel mundial, no se han encontrado c√°maras vulnerables AXIS de todo los modelos si no que, en concreto, s√≥lo `r vulnerable.models.count ` presentan problemas de seguridad.

```{r, axisVulnsByModel, fig.align='center'}
g <- ggplot(shodan_cves_join.no_na[shodan_cves_join.no_na$vendor == "axis",], aes(model, fill = version))
g + geom_bar() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + labs(title = "Recuento de modelos de c√°maras vulnerables a nivel mundial", y = "Recuento por modelo", x = "Modelo", fill = "Versi√≥n")
```

De esta manera, los diferentes modelos vulnerables se reparten de la siguiente forma:  

```{r, axisVulnsByCountryAndModel, fig.align='center'}
g <- ggplot(shodan_cves_join.no_na[shodan_cves_join.no_na$vendor == "axis",], aes(country_code, fill = model))
g + geom_bar() + labs(title = "Repartici√≥n de modelos de c√°maras AXIS a nivel mundial", y = "Recuento de c√°maras vunerables", x = "Pa√≠s", fill = "Fabricante")
```

Dada la lista de pa√≠ses que cuentan con c√°maras vulnerables AXIS y sabiendo que el modelo 2100 Network Camera es el m√°s vulnerable, podr√≠amos determinar en qu√© medida los pa√≠ses que cuentan con c√°maras AXIS se ven afectados por este modelo.

```{r, calculatePercentOf2100Axis, include=FALSE}
## Get percent of 2100 network camera by country
axis.total <-  data.frame(table(shodan_cves_join.no_na$country_code))
colnames(axis.total) <- c("country", "freq1")

axis.2100 <- data.frame(table(shodan_cves_join.no_na[shodan_cves_join.no_na$model == "2100 network camera",]$country_code))
colnames(axis.2100) <- c("country", "freq2")

axis.percent <- left_join(axis.total, axis.2100)
axis.percent$percent <- (axis.percent$freq2/axis.percent$freq1)*100
axis.percent <- axis.percent %>% drop_na()
```

```{r, percentOf2100Axis, warning=FALSE, fig.align='center'}
ggplot(axis.percent, aes(country, percent)) + geom_point(aes(size = percent)) + labs(title = "Repartici√≥n de c√°maras vulnerables AXIS 2100 Network Camera", y = "Porcentaje de c√°maras vulnerables", x = "Pa√≠s", size = "Porcentaje")
```

Pero el n√∫mero de c√°maras vulnerables no es el √∫nico dato importante a la hora de analizar c√≥mo de inseguro es un dispositivo si no que hay otro dato, llamado CVSS (Common Vulnerability Scoring System) que nos permite determinar la gravedad de una vulnerabilidad. De esta manera, volviendo a la lista de c√°maras vulnerables encontradas a nivel mundial, podemos determinar c√≥mo de grave puede llegar a ser el impacto de √©stas.  

```{r, cvssImpactAxis, warning=FALSE, message=FALSE, fig.align='center'}
axis.cvss <- data.frame(table(shodan_cves_join.no_na$cvss))
ggplot(shodan_cves_join.no_na, aes(cvss, fill = model)) + geom_histogram(binwidth = 1) + labs(title = "Recueto de valores de CVSS por modelo de c√°maras AXIS", y = "Recuento", x = "Valor CVSS", size = "Modelo")
```

Como se puede observar, muchas de las c√°maras encontradas a nivel mundial, cuentan con problemas de seguridad cuyo impacto puede no llegar a ser representativo mientras que un total de `r axis.cvss[axis.cvss$Var1 == 10,]$Freq ` c√°maras cuentan con vulnerabilidades cuyo valor de CVSS es m√°ximo. De esta manera, si analizamos c√≥mo se reparten los diferentes modelos de c√°maras AXIS vulnerables junto a la gravedad de estas vulnerabilidades obtenemos los siguientes datos:  

```{r, cvssAxisCamerasWorldWide, warning=FALSE, fig.align='center'}
ggplot(shodan_cves_join.no_na, aes(country_code, cvss, color = model)) + geom_count() + labs(title = "Recueto c√°maras vulnerables a nivel mundial por modelo y gravedad de la vulnerabilidad", y = "Valor CVSS", x = "Pa√≠s", size = "Recuento de c√°maras", color = "Modelo")
```

### Conclusiones  

En primer lugar, como se ha comentado a lo largo del informe, los datos que se han obtenido no han sido suficientes para realizar un estudio detallado y por lo tanto, no nos han permitido contestar a la pregunta hecha inicialmente. A√∫n as√≠, cabe destacar el gran problema que est√° suponiendo la falta de aplicaci√≥n de medidas de seguridad en este tipo de dispositivos. √âstos van desde la creaci√≥n de botnets hasta problemas de privacidad que ir√°n siendo cada vez m√°s cr√≠ticos a causa de un aumento masivo en el n√∫mero de instalaciones de c√°maras IP.  

Por lo tanto, los usuarios tienen que estar concienciados de los problemas que este tipo de dispositivos pueden generar y de la importancia de la seguridad para poder evitar ataques inform√°ticos o filtraciones de informaci√≥n no deseada.  
  

### Aspectos a mejorar y trabajos futuros  

A lo largo de la realizaci√≥n de este trabajo han surgido varios problemas e ideas que se podr√≠an tener en cuenta para una futura mejora y ampliaci√≥n del proyecto:  

1. El aspecto principal a mejorar es el proceso de obtenci√≥n de los datos ya que √©ste ha sido la causa principal de que el resultado obtenido no fuese el esperado. Como se ha comentado, el principal inconveniente ha sido el no disponer de informaci√≥n completa de modelo y versi√≥n de los diferentes fabricantes de c√°maras IP, impidiendo poder determinar las vulnerabilidades de ciertos fabricantes de c√°maras. Por lo tanto, si se encontrase una manera alternativa de obtener la informaci√≥n necesaria, se dispondr√≠a de datos suficientes para realizar un estudio detallado de las c√°maras m√°s vulnerables a nivel mundial.  

2. Para la realizaci√≥n de este proyecto se han escogido un total de 6 modelos de c√°maras, pero para que el estudio sea real, se tendr√≠a que hacer un an√°lisis de todos los modelos presentes en el mercado o al menos incluyendo todos los fabricantes m√°s populares. Esto se podr√≠a llevar a cabo disponiendo de un dataset de CPEs completo ya que como se ha detallado en los apartados anteriores, el que se ha utilizado para este trabajo no estaba completo.

3. Por otro lado, una parte muy interesante a continuar con el estudio ser√≠a no s√≥lo ver cu√°ntas vulnerabilidades tienen determinadas marcas sino de qu√© tipo, pero esta pregunta nos queda limitada a la dificultad que hemos tenido por los medios t√©cnicos utilizados en la b√∫squeda de datos para el estudio.  

4. Como se hab√≠a pensado inicialmente, otro estudio podr√≠a centrarse en determinar qu√© c√°maras infringen la ley de protecci√≥n de datos, pero para ello se tendr√≠a que buscar una manera de analizar qu√© tipo de informaci√≥n est√°n captando las diferentes c√°maras de videovigilancia presentes en la red.
